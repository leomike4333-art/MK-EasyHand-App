<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MK EasyHand App</title>

  <!-- Tesseract.js (OCR in-browser) -->
  <script src="https://unpkg.com/tesseract.js@5.0.5/dist/tesseract.min.js"></script>

  <style>
    :root{
      --bg:#f6f7f9; --card:#fff; --ink:#111; --muted:#666;
      --ok:#118a3b; --bad:#b00020; --btn:#2563eb; --btn2:#0f7a3a;
      --border:#d7dbe2;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--ink)}
    header{background:#fff;border-bottom:1px solid var(--border);padding:12px 16px}
    h1{margin:0;font-size:22px;letter-spacing:.2px}
    .sub{margin-top:4px;color:var(--muted);font-size:13px}
    .wrap{padding:14px;max-width:1100px;margin:0 auto}
    .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
    .card{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:12px}
    .card.wide{flex:1 1 560px}
    .card.side{flex:1 1 340px}
    label{font-size:13px;color:var(--muted)}
    select,button,input[type="file"]{font:inherit}
    select{padding:8px 10px;border:1px solid var(--border);border-radius:10px;background:#fff}
    button{border:0;border-radius:10px;padding:9px 12px;color:#fff;cursor:pointer}
    .btn{background:var(--btn)}
    .btn2{background:var(--btn2)}
    .btnGrey{background:#4b5563}
    .pill{display:inline-flex;align-items:center;gap:8px;padding:7px 10px;border:1px solid var(--border);border-radius:999px;background:#fff}
    .status{font-weight:700}
    .ok{color:var(--ok)}
    .bad{color:var(--bad)}
    .hint{font-size:13px;color:var(--muted);line-height:1.35;margin-top:6px}
    .canvasWrap{margin-top:10px;border:1px solid var(--border);border-radius:12px;overflow:hidden;background:#fff}
    canvas{width:100%;height:auto;display:block;cursor:crosshair}
    .small{font-size:12px;color:var(--muted);margin-top:8px}
    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media (max-width: 820px){ .grid2{grid-template-columns:1fr} }
    table{border-collapse:collapse;width:100%}
    th,td{border:1px solid var(--border);padding:8px 10px;font-size:14px}
    th{background:#f3f4f6;text-align:left}
    textarea{width:100%;min-height:92px;border:1px solid var(--border);border-radius:10px;padding:10px;font:12px ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
    .tools{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
    a.tool{display:inline-block;text-decoration:none;background:#111827;color:#fff;padding:8px 10px;border-radius:10px;font-size:13px}
    .note{font-size:12px;color:var(--muted);margin-top:6px}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
    .busy{opacity:.7;pointer-events:none}
  </style>
</head>

<body>
<header>
  <h1>MK EasyHand App</h1>
  <div class="sub">Screenshot ‚Üí <b>Paste</b> / Upload ‚Üí <b>Click a suit icon</b> (‚ô†/‚ô•/‚ô¶/‚ô£) ‚Üí OCR ‚Üí Table ‚Üí Open Solver / BBO</div>
</header>

<div class="wrap">
  <div class="card">
    <div class="row" style="justify-content:space-between">
      <div class="row">
        <div>
          <label>Source</label><br/>
          <select id="sourceSel">
            <option value="A">A ‚Äî RealBridge</option>
            <option value="B">B ‚Äî BBO</option>
            <option value="C" selected>C ‚Äî Federation / Local (FIGB)</option>
            <option value="D">D ‚Äî LoveBridge</option>
          </select>
        </div>

        <div class="row" style="gap:8px">
          <button id="pasteBtn" class="btn" title="Paste image from clipboard">üìã Paste</button>
          <div>
            <label>or Upload</label><br/>
            <input id="fileInput" type="file" accept="image/*" />
          </div>
        </div>
      </div>

      <div class="row">
        <span class="pill"><span id="imgLoaded">Image: ‚ùå</span></span>
        <span class="pill status" id="valBadge">Validation: <span class="bad">KO ‚úñ</span></span>
      </div>
    </div>

    <div class="hint" id="modeHint">
      <b>FIGB mode (Source C):</b> paste/upload ‚Üí <b>click directly on ONE suit icon</b> (‚ô†/‚ô•/‚ô¶/‚ô£) near the hand you want to read.
      OCR is ‚Äúrestricted‚Äù to ranks <span class="mono">AKQJT98765432</span> and <span class="mono">10‚ÜíT</span>.
      <br/>Tip: if you don‚Äôt see updates on GitHub Pages, hard-refresh (Ctrl+F5) or add <span class="mono">?v=123</span>.
    </div>

    <div class="canvasWrap">
      <canvas id="cv"></canvas>
    </div>

    <div class="small" id="clickMsg">No click yet.</div>

    <div class="tools">
      <button id="runBtn" class="btn2">Generate LIN/PBN (validate)</button>
      <button id="clearBtn" class="btnGrey">Clear</button>
    </div>
  </div>

  <div class="grid2" style="margin-top:12px">
    <div class="card wide">
      <h3 style="margin:0 0 10px 0">Hand table (52 cards)</h3>
      <div class="small">Seats are inferred from click position (N/E/S/W). You can also edit cells manually.</div>

      <div style="overflow:auto;margin-top:10px">
        <table>
          <thead>
            <tr>
              <th>Seat</th>
              <th>‚ô† Spades</th>
              <th>‚ô• Hearts</th>
              <th>‚ô¶ Diamonds</th>
              <th>‚ô£ Clubs</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><b>North</b></td>
              <td><input id="N_S" style="width:100%" placeholder="e.g. AKQJ" /></td>
              <td><input id="N_H" style="width:100%" placeholder="e.g. T987" /></td>
              <td><input id="N_D" style="width:100%" placeholder="e.g. 642" /></td>
              <td><input id="N_C" style="width:100%" placeholder="e.g. A73" /></td>
            </tr>
            <tr>
              <td><b>East</b></td>
              <td><input id="E_S" style="width:100%" /></td>
              <td><input id="E_H" style="width:100%" /></td>
              <td><input id="E_D" style="width:100%" /></td>
              <td><input id="E_C" style="width:100%" /></td>
            </tr>
            <tr>
              <td><b>South</b></td>
              <td><input id="S_S" style="width:100%" /></td>
              <td><input id="S_H" style="width:100%" /></td>
              <td><input id="S_D" style="width:100%" /></td>
              <td><input id="S_C" style="width:100%" /></td>
            </tr>
            <tr>
              <td><b>West</b></td>
              <td><input id="W_S" style="width:100%" /></td>
              <td><input id="W_H" style="width:100%" /></td>
              <td><input id="W_D" style="width:100%" /></td>
              <td><input id="W_C" style="width:100%" /></td>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="note" style="margin-top:10px">
        Allowed ranks: <span class="mono">AKQJT98765432</span> (use <b>T</b> or <b>10</b>). Spaces are ignored.
      </div>
    </div>

    <div class="card side">
      <h3 style="margin:0 0 10px 0">Output</h3>

      <label>LIN output</label>
      <textarea id="linOut" readonly>(will appear here)</textarea>

      <label style="margin-top:10px;display:block">PBN output</label>
      <textarea id="pbnOut" readonly>(will appear here)</textarea>

      <div class="tools">
        <button id="copyLin" class="btnGrey">Copy LIN</button>
        <button id="dlLin" class="btn">Download .lin</button>
      </div>

      <div class="tools">
        <a id="openBSOL" class="tool" href="#" target="_blank" rel="noopener">Open Bridge Solver Online</a>
        <a id="openBBO" class="tool" href="#" target="_blank" rel="noopener">Open BBO Handviewer</a>
      </div>

      <div class="note">
        <b>Debug</b>
        <pre id="debug" class="mono" style="white-space:pre-wrap;background:#f3f4f6;border:1px solid var(--border);border-radius:10px;padding:10px;max-height:240px;overflow:auto"></pre>
      </div>
    </div>
  </div>
</div>

<script>
/* =======================
   Helpers / state
======================= */
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d', { willReadFrequently:true });
const pasteBtn = document.getElementById('pasteBtn');
const fileInput = document.getElementById('fileInput');
const sourceSel = document.getElementById('sourceSel');
const imgLoadedLbl = document.getElementById('imgLoaded');
const clickMsg = document.getElementById('clickMsg');
const runBtn = document.getElementById('runBtn');
const clearBtn = document.getElementById('clearBtn');
const debugEl = document.getElementById('debug');
const valBadge = document.getElementById('valBadge');
const linOut = document.getElementById('linOut');
const pbnOut = document.getElementById('pbnOut');
const copyLinBtn = document.getElementById('copyLin');
const dlLinBtn = document.getElementById('dlLin');
const openBSOL = document.getElementById('openBSOL');
const openBBO = document.getElementById('openBBO');

const cells = {
  N:{S:byId('N_S'),H:byId('N_H'),D:byId('N_D'),C:byId('N_C')},
  E:{S:byId('E_S'),H:byId('E_H'),D:byId('E_D'),C:byId('E_C')},
  S:{S:byId('S_S'),H:byId('S_H'),D:byId('S_D'),C:byId('S_C')},
  W:{S:byId('W_S'),H:byId('W_H'),D:byId('W_D'),C:byId('W_C')},
};

function byId(id){ return document.getElementById(id); }

let img = null;
let imgW=0, imgH=0;
let lastClick = null; // {x,y,nx,ny}
let lastAnchor = null; // {seat, suit, x,y}

/* =======================
   Image load / draw
======================= */
function setDebug(text){ debugEl.textContent = text || ""; }
function appendDebug(text){ debugEl.textContent += (debugEl.textContent ? "\n" : "") + text; }

function setLoaded(yes){
  imgLoadedLbl.textContent = yes ? "Image: ‚úÖ" : "Image: ‚ùå";
}

function drawImage(){
  if(!img) return;
  // Render at natural resolution for OCR accuracy.
  cv.width = imgW;
  cv.height = imgH;
  ctx.clearRect(0,0,cv.width,cv.height);
  ctx.drawImage(img,0,0);
}

function loadFromBlob(blob){
  return new Promise((resolve,reject)=>{
    const url = URL.createObjectURL(blob);
    const im = new Image();
    im.onload = ()=>{
      img = im; imgW = im.naturalWidth; imgH = im.naturalHeight;
      setLoaded(true);
      drawImage();
      clickMsg.textContent = "Image ready. Click on a suit icon (‚ô†/‚ô•/‚ô¶/‚ô£) near the hand you want to read.";
      setDebug("");
      resolve();
      URL.revokeObjectURL(url);
    };
    im.onerror = reject;
    im.src = url;
  });
}

/* =======================
   Paste / Upload
======================= */
pasteBtn.addEventListener('click', async ()=>{
  try{
    if(!navigator.clipboard || !navigator.clipboard.read){
      alert("Paste not supported in this browser. Use Upload instead.");
      return;
    }
    const items = await navigator.clipboard.read();
    for (const item of items){
      const types = item.types || [];
      const imgType = types.find(t=>t.startsWith('image/'));
      if(imgType){
        const blob = await item.getType(imgType);
        await loadFromBlob(blob);
        return;
      }
    }
    alert("No image found in clipboard. Take a screenshot, copy it, then press Paste.");
  }catch(e){
    alert("Paste failed. Some browsers require HTTPS and permissions. Try Upload.\n\n" + e);
  }
});

fileInput.addEventListener('change', async ()=>{
  const f = fileInput.files && fileInput.files[0];
  if(!f) return;
  await loadFromBlob(f);
});

/* =======================
   Click handling
======================= */
cv.addEventListener('click', (ev)=>{
  if(!img) return;

  // Map click to canvas pixel coords (taking CSS scale into account)
  const rect = cv.getBoundingClientRect();
  const x = Math.round((ev.clientX - rect.left) * (cv.width / rect.width));
  const y = Math.round((ev.clientY - rect.top) * (cv.height / rect.height));

  const nx = +(x / imgW).toFixed(3);
  const ny = +(y / imgH).toFixed(3);
  lastClick = {x,y,nx,ny};

  const seat = inferSeat(x,y);
  const suit = inferSuitFromColor(x,y);

  lastAnchor = {seat, suit, x, y};

  clickMsg.textContent = `Clicked at x=${x}, y=${y} | normalized (${nx}, ${ny}) | seat=${seat} | suit=${suit}`;
  setDebug(`Anchor:\n seat=${seat}\n suit=${suit}\n x=${x}\n y=${y}\n img=${imgW}x${imgH}\n source=${sourceSel.value}`);
});

function inferSeat(x,y){
  const cx = imgW/2, cy = imgH/2;
  const dx = x - cx, dy = y - cy;

  // Strong vertical => N/S; else E/W
  if(Math.abs(dy) > Math.abs(dx)){
    return (dy < 0) ? "N" : "S";
  }else{
    return (dx < 0) ? "W" : "E";
  }
}

// FIGB icons are colored: ‚ô† blue, ‚ô• red, ‚ô¶ orange, ‚ô£ green.
// We'll sample a small box around click and decide.
function inferSuitFromColor(x,y){
  const s = 6; // half-size
  const x0 = clamp(x - s, 0, imgW-1);
  const y0 = clamp(y - s, 0, imgH-1);
  const w = clamp(2*s, 1, imgW - x0);
  const h = clamp(2*s, 1, imgH - y0);
  const data = ctx.getImageData(x0,y0,w,h).data;

  let r=0,g=0,b=0,n=0;
  for(let i=0;i<data.length;i+=4){
    r += data[i]; g += data[i+1]; b += data[i+2];
    n++;
  }
  r/=n; g/=n; b/=n;

  // Heuristic mapping
  // red-ish => H; green-ish => C; orange-ish => D; blue-ish => S
  // We'll use channel dominance + thresholds.
  if(r > g + 40 && r > b + 40) return "H";       // heart red
  if(g > r + 35 && g > b + 35) return "C";       // club green
  if(r > 140 && g > 90 && b < 120) return "D";   // diamond orange
  return "S"; // default spade (blue/other)
}

function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

/* =======================
   OCR core (Source C focus)
======================= */
const ALLOWED = "AKQJT9876543210";
function normalizeRanks(text){
  if(!text) return "";
  let t = text.toUpperCase();
  t = t.replace(/10/g, "T");          // 10 -> T
  t = t.replace(/[^AKQJT98765432]/g, ""); // keep only ranks (no 1/0 after conversion)
  return t;
}

// preprocess: crop -> grayscale -> threshold
function cropAndPreprocess(x,y,w,h){
  const sx = clamp(Math.round(x), 0, imgW-1);
  const sy = clamp(Math.round(y), 0, imgH-1);
  const sw = clamp(Math.round(w), 1, imgW - sx);
  const sh = clamp(Math.round(h), 1, imgH - sy);

  const off = document.createElement("canvas");
  off.width = sw; off.height = sh;
  const octx = off.getContext("2d", { willReadFrequently:true });
  octx.drawImage(cv, sx, sy, sw, sh, 0, 0, sw, sh);

  const id = octx.getImageData(0,0,sw,sh);
  const d = id.data;

  // simple threshold
  for(let i=0;i<d.length;i+=4){
    const rr=d[i], gg=d[i+1], bb=d[i+2];
    const lum = 0.299*rr + 0.587*gg + 0.114*bb;
    const v = (lum < 175) ? 0 : 255; // tweak
    d[i]=d[i+1]=d[i+2]=v;
    d[i+3]=255;
  }
  octx.putImageData(id,0,0);
  return off;
}

async function ocrCanvas(offCanvas){
  const res = await Tesseract.recognize(offCanvas, "eng", {
    tessedit_char_whitelist: ALLOWED,
  });
  return res.data && res.data.text ? res.data.text : "";
}

function suitIndex(suit){
  // FIGB order visually: Spade, Heart, Diamond, Club
  return suit==="S" ? 0 : suit==="H" ? 1 : suit==="D" ? 2 : 3;
}

async function readFIGBFromAnchor(anchor){
  // Strategy:
  // - user clicks on a suit icon near a hand
  // - infer seat by position
  // - infer suit by color
  // - compute topY for spade line using dy candidates (adaptive)
  // - OCR 4 lines using crop from "right of icon" to right area

  const seat = anchor.seat;
  const clickedSuit = anchor.suit;
  const idx = suitIndex(clickedSuit);

  // icon box assumptions: icon sits just left of ranks. We crop to the right.
  const iconW = imgW * 0.035;             // relative guess
  const xText = anchor.x + iconW * 1.05;  // start OCR after icon
  const wText = imgW * 0.22;              // enough for long suit strings
  const lineH = imgH * 0.045;             // line height

  // dy candidates (vertical distance between suit lines) as % of image height
  const dyCands = [0.030, 0.034, 0.038, 0.042].map(k=>imgH*k);

  appendDebug(`\nFIGB OCR: starting...\n seat=${seat} clickedSuit=${clickedSuit} idx=${idx}`);
  let best = null;

  for(const dy of dyCands){
    // compute y for spade line by stepping back idx*dy
    const ySpade = anchor.y - idx*dy;

    const suits = ["S","H","D","C"];
    const out = {S:"",H:"",D:"",C:""};
    let score = 0;

    for(let i=0;i<4;i++){
      const yLine = ySpade + i*dy - lineH*0.55;
      const off = cropAndPreprocess(xText, yLine, wText, lineH);
      const raw = await ocrCanvas(off);
      const norm = normalizeRanks(raw);
      out[suits[i]] = norm;
      score += norm.length; // crude score = how many ranks read
    }

    // prefer solutions with plausible lengths (0..13 each)
    const perSuitOk = suits.every(s=>out[s].length<=13);
    const bonus = perSuitOk ? 20 : 0;
    const totalScore = score + bonus;

    appendDebug(`dy=${Math.round(dy)} score=${score} bonus=${bonus}  => S=${out.S} H=${out.H} D=${out.D} C=${out.C}`);

    if(!best || totalScore > best.totalScore){
      best = {dy, out, totalScore};
    }
  }

  appendDebug(`\nFIGB OCR: best dy=${Math.round(best.dy)}\n` +
              `S=${best.out.S}\nH=${best.out.H}\nD=${best.out.D}\nC=${best.out.C}\nFIGB OCR: done.`);

  // write into table
  cells[seat].S.value = best.out.S;
  cells[seat].H.value = best.out.H;
  cells[seat].D.value = best.out.D;
  cells[seat].C.value = best.out.C;

  return seat;
}

/* =======================
   Validation + outputs
======================= */
function getAllHands(){
  const hands = {};
  for(const seat of ["N","E","S","W"]){
    hands[seat] = {
      S: normalizeRanks(cells[seat].S.value),
      H: normalizeRanks(cells[seat].H.value),
      D: normalizeRanks(cells[seat].D.value),
      C: normalizeRanks(cells[seat].C.value),
    };
  }
  return hands;
}

function countCards(hands){
  const counts = {N:0,E:0,S:0,W:0,total:0};
  for(const seat of ["N","E","S","W"]){
    const c = hands[seat].S.length + hands[seat].H.length + hands[seat].D.length + hands[seat].C.length;
    counts[seat]=c; counts.total += c;
  }
  return counts;
}

function buildCardSet(hands){
  const seen = new Map(); // card -> occurrences
  const ranks = "AKQJT98765432";
  function add(seat, suit, str){
    for(const ch of str){
      if(!ranks.includes(ch)) continue;
      const card = suit + ch;
      seen.set(card, (seen.get(card)||0) + 1);
    }
  }
  for(const seat of ["N","E","S","W"]){
    add(seat,"S",hands[seat].S);
    add(seat,"H",hands[seat].H);
    add(seat,"D",hands[seat].D);
    add(seat,"C",hands[seat].C);
  }
  return seen;
}

function validate(hands){
  const errors = [];
  const counts = countCards(hands);

  if(counts.total !== 52){
    errors.push(`Total cards: ${counts.total} (expected 52)`);
  }
  for(const seat of ["N","E","S","W"]){
    if(counts[seat] !== 13){
      errors.push(`Seat ${seat}: ${counts[seat]} cards (expected 13)`);
    }
  }

  const seen = buildCardSet(hands);
  const dups = [];
  for(const [card, n] of seen.entries()){
    if(n>1) dups.push(`${card}√ó${n}`);
  }
  if(dups.length) errors.push(`Duplicates: ${dups.join(", ")}`);

  // missing list (optional)
  const missing = [];
  const suits = ["S","H","D","C"];
  const ranks = "AKQJT98765432";
  for(const s of suits){
    for(const r of ranks){
      const card = s+r;
      if(!seen.has(card)) missing.push(card);
    }
  }
  // don't spam unless big issue
  if(missing.length && missing.length<=20) errors.push(`Missing: ${missing.join(" ")}`);
  else if(missing.length>20) errors.push(`Missing (first 20): ${missing.slice(0,20).join(" ")} ...`);

  return {ok: errors.length===0, errors, counts};
}

function makePBN(hands){
  // PBN Deal format: N:spades.hearts.diamonds.clubs  (order N E S W)
  function one(seat){
    return `${hands[seat].S}.${hands[seat].H}.${hands[seat].D}.${hands[seat].C}`;
  }
  return `[\n`+
    `[Event "MK EasyHand"]\n`+
    `[Site "GitHub Pages"]\n`+
    `[Dealer "N"]\n`+
    `[Vulnerable "None"]\n`+
    `[Deal "N:${one("N")} ${one("E")} ${one("S")} ${one("W")}"]\n`+
    `]\n`;
}

function makeLIN(hands){
  // Minimal LIN containing only hands in a common pattern.
  // NOTE: Different viewers accept different LIN dialects; we also provide direct URLs.
  // We'll output a pragmatic string (works for many tools).
  // Hands string in PBN order: N E S W separated by commas, each as SHDC concatenated.
  function concat(seat){ return hands[seat].S + hands[seat].H + hands[seat].D + hands[seat].C; }
  const deal = `${concat("N")},${concat("E")},${concat("S")},${concat("W")}`;
  return `pn|N,E,S,W|sv|o|bd|1|md|${deal}|`;
}

function makeSolverURL(hands){
  // Bridge Solver Online accepts query parameters north/east/south/west in SHDC dot format.
  // (If their format differs, you still have PBN/LIN to copy.)
  function dot(seat){ return `${hands[seat].S}.${hands[seat].H}.${hands[seat].D}.${hands[seat].C}`; }
  const base = "https://www.bridgebase.com/tools/handviewer.html";
  // BBO handviewer supports (often): ?n=...&e=...&s=...&w=...
  const q = `?n=${encodeURIComponent(dot("N"))}&e=${encodeURIComponent(dot("E"))}&s=${encodeURIComponent(dot("S"))}&w=${encodeURIComponent(dot("W"))}`;
  return { bbo: base + q, solver: "https://bridgesolveronline.com/?n=" + encodeURIComponent(dot("N")) +
                                 "&e=" + encodeURIComponent(dot("E")) +
                                 "&s=" + encodeURIComponent(dot("S")) +
                                 "&w=" + encodeURIComponent(dot("W")) };
}

function setValidation(ok, msg){
  valBadge.innerHTML = `Validation: <span class="${ok?'ok':'bad'}">${ok?'OK ‚úî':'KO ‚úñ'}</span>`;
  if(msg) appendDebug(msg);
}

/* =======================
   Main action
======================= */
runBtn.addEventListener('click', async ()=>{
  try{
    if(!img){
      alert("Paste or upload an image first.");
      return;
    }
    runBtn.classList.add("busy");
    runBtn.textContent = "Working...";

    setDebug(debugEl.textContent || "");
    const src = sourceSel.value;

    // If Source C and we have an anchor click, attempt OCR for that seat
    if(src === "C"){
      if(!lastAnchor){
        alert("Source C: first click on ONE suit icon (‚ô†/‚ô•/‚ô¶/‚ô£) near the hand you want to read.");
        return;
      }
      await readFIGBFromAnchor(lastAnchor);
    }else{
      appendDebug(`\nSource ${src}: OCR for this source is not enabled in this build.\n`+
                  `Use Source C (FIGB) click-OCR, or fill the table manually.`);
    }

    // Validate and output
    const hands = getAllHands();
    const v = validate(hands);

    if(!v.ok){
      setValidation(false, `\nValidation: OK=false  total=${v.counts.total}\nErrors:\n- ` + v.errors.join("\n- "));
      linOut.value = "";
      pbnOut.value = "";
      openBSOL.href = "#";
      openBBO.href = "#";
      return;
    }

    setValidation(true, `\nValidation: OK=true total=52\nNo errors.`);
    const pbn = makePBN(hands);
    const lin = makeLIN(hands);
    pbnOut.value = pbn;
    linOut.value = lin;

    const urls = makeSolverURL(hands);
    openBSOL.href = urls.solver;
    openBBO.href = urls.bbo;

  }catch(e){
    appendDebug("\nERROR:\n" + (e && e.stack ? e.stack : e));
    setValidation(false);
    alert("Error:\n" + e);
  }finally{
    runBtn.classList.remove("busy");
    runBtn.textContent = "Generate LIN/PBN (validate)";
  }
});

clearBtn.addEventListener('click', ()=>{
  for(const seat of ["N","E","S","W"]){
    for(const s of ["S","H","D","C"]) cells[seat][s].value = "";
  }
  linOut.value = "(will appear here)";
  pbnOut.value = "(will appear here)";
  setDebug("");
  setValidation(false);
});

copyLinBtn.addEventListener('click', async ()=>{
  const t = linOut.value || "";
  if(!t || t.includes("will appear")) return;
  try{
    await navigator.clipboard.writeText(t);
    alert("LIN copied.");
  }catch(e){
    alert("Copy failed. Select and copy manually.");
  }
});

dlLinBtn.addEventListener('click', ()=>{
  const t = linOut.value || "";
  if(!t || t.includes("will appear")) return;
  const blob = new Blob([t], {type:"text/plain"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "hand.lin";
  document.body.appendChild(a);
  a.click();
  a.remove();
});

/* Revalidate live when user edits table manually */
for(const seat of ["N","E","S","W"]){
  for(const s of ["S","H","D","C"]){
    cells[seat][s].addEventListener('input', ()=>{
      const hands = getAllHands();
      const v = validate(hands);
      valBadge.innerHTML = `Validation: <span class="${v.ok?'ok':'bad'}">${v.ok?'OK ‚úî':'KO ‚úñ'}</span>`;
    });
  }
}
</script>
</body>
</html>
