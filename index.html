<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MK EasyHand ‚Äì Standard</title>

  <!-- OCR -->
  <script src="https://unpkg.com/tesseract.js@5.0.5/dist/tesseract.min.js"></script>

  <style>
    :root{
      --bg:#f6f7fb; --card:#fff; --bd:#e5e7eb; --txt:#111827; --muted:#6b7280;
      --ok:#16a34a; --bad:#dc2626; --blue:#2563eb; --dark:#111827;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--txt)}
    header{background:#fff;border-bottom:1px solid var(--bd);padding:12px 16px}
    h1{margin:0;font-size:22px;font-weight:900}
    .sub{margin-top:4px;color:var(--muted);font-size:13px;line-height:1.3}
    .wrap{max-width:1100px;margin:0 auto;padding:14px 16px 24px}
    .card{background:var(--card);border:1px solid var(--bd);border-radius:14px;padding:12px;margin-top:12px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    label{font-size:13px;color:var(--muted)}
    select,input[type="file"],input[type="text"]{
      padding:9px 10px;border:1px solid var(--bd);border-radius:12px;background:#fff;font:inherit
    }
    button{
      border:0;border-radius:12px;padding:10px 12px;font-weight:800;cursor:pointer;
      color:#fff;background:var(--blue);display:inline-flex;gap:8px;align-items:center
    }
    button.dark{background:var(--dark)}
    button.gray{background:#4b5563}
    button.green{background:var(--ok)}
    button.red{background:var(--bad)}
    button:disabled{opacity:.55;cursor:not-allowed}

    .pill{display:inline-flex;gap:8px;align-items:center;padding:7px 10px;border:1px solid var(--bd);border-radius:999px;background:#fff;font-weight:800}
    .ok{color:var(--ok)}
    .bad{color:var(--bad)}
    .small{font-size:12px;color:var(--muted)}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}

    .grid2{display:grid;grid-template-columns:1.05fr .95fr;gap:12px}
    @media(max-width:980px){.grid2{grid-template-columns:1fr}}

    .imgBox{border:1px solid var(--bd);border-radius:14px;overflow:hidden;background:#fff}
    #imgPreview{display:none;width:100%;height:auto;cursor:crosshair}

    table{border-collapse:collapse;width:100%;background:#fff;border:1px solid var(--bd);border-radius:14px;overflow:hidden}
    th,td{border:1px solid var(--bd);padding:8px 10px;font-size:14px}
    th{background:#f3f4f6;text-align:left}
    td input{width:100%;padding:7px 8px;border-radius:10px;border:1px solid var(--bd)}
    textarea{width:100%;min-height:110px;border:1px solid var(--bd);border-radius:12px;padding:10px;font:12px ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}

    .hint{border:1px dashed var(--bd);border-radius:12px;padding:10px;background:#fff;color:var(--muted);margin-top:10px}
  </style>
</head>

<body>
<header>
  <h1>MK EasyHand ‚Äì Standard</h1>
  <div class="sub">Flusso unico: Paste/Upload ‚Üí scegli Seat (N/E/S/W) ‚Üí clicca sulla ‚ô† della mano ‚Üí OCR ‚Üí ripeti per 4 mani ‚Üí Generate LIN/PBN ‚Üí Solver/BBO. Se OCR sbaglia: correggi a mano.</div>
</header>

<div class="wrap">

  <div class="card">
    <div class="row">
      <button id="pasteBtn">üìã Paste</button>
      <input type="file" id="fileInput" accept="image/*" />

      <label><b>Seat</b></label>
      <select id="seatSel">
        <option value="N">North</option>
        <option value="E">East</option>
        <option value="S">South</option>
        <option value="W">West</option>
      </select>

      <span class="pill">Image: <span id="imgState" class="bad">not loaded</span></span>
      <span class="pill">Hands: <span id="filled" class="mono">N ‚òê E ‚òê S ‚òê W ‚òê</span></span>
      <span class="pill">Validation: <span id="valState" class="bad">KO ‚úñ</span></span>

      <button id="ocrBtn" class="green" disabled>üîé OCR (from ‚ô† click)</button>
      <button id="genBtn" class="dark">Generate LIN / PBN</button>
      <button id="clearBtn" class="red">Clear</button>
    </div>

    <div class="hint">
      <b>Regola standard:</b> clicca SEMPRE sulla <b>‚ô†</b> (picche) della mano che vuoi leggere.
      L‚Äôapp legger√† automaticamente anche ‚ô• ‚ô¶ ‚ô£ sotto.
      <br><b>Nota:</b> alcuni formati ‚ÄúFIGB allungati‚Äù possono dare errori: in quel caso correggi manualmente in tabella.
    </div>
  </div>

  <div class="grid2">
    <div class="card">
      <div class="small"><b>Immagine</b> (clicca sulla ‚ô† della mano scelta)</div>
      <div class="imgBox" style="margin-top:8px">
        <img id="imgPreview" alt="preview" />
      </div>
      <div id="clickMsg" class="small mono" style="margin-top:8px">No click yet.</div>

      <details style="margin-top:10px">
        <summary class="small">Debug (opzionale)</summary>
        <textarea id="debug" readonly></textarea>
      </details>
    </div>

    <div class="card">
      <div class="small"><b>Tabella mano (52 carte)</b> ‚Äî solo carte</div>

      <div style="overflow:auto;margin-top:10px">
        <table>
          <thead>
            <tr>
              <th>Seat</th>
              <th>‚ô†</th>
              <th>‚ô•</th>
              <th>‚ô¶</th>
              <th>‚ô£</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><b>North</b></td>
              <td><input id="N_S" class="mono" placeholder="AKQJ" /></td>
              <td><input id="N_H" class="mono" placeholder="T987" /></td>
              <td><input id="N_D" class="mono" placeholder="642" /></td>
              <td><input id="N_C" class="mono" placeholder="A73" /></td>
            </tr>
            <tr>
              <td><b>East</b></td>
              <td><input id="E_S" class="mono" /></td>
              <td><input id="E_H" class="mono" /></td>
              <td><input id="E_D" class="mono" /></td>
              <td><input id="E_C" class="mono" /></td>
            </tr>
            <tr>
              <td><b>South</b></td>
              <td><input id="S_S" class="mono" /></td>
              <td><input id="S_H" class="mono" /></td>
              <td><input id="S_D" class="mono" /></td>
              <td><input id="S_C" class="mono" /></td>
            </tr>
            <tr>
              <td><b>West</b></td>
              <td><input id="W_S" class="mono" /></td>
              <td><input id="W_H" class="mono" /></td>
              <td><input id="W_D" class="mono" /></td>
              <td><input id="W_C" class="mono" /></td>
            </tr>
          </tbody>
        </table>
      </div>

      <div class="small" style="margin-top:8px">
        Allowed ranks: <span class="mono">AKQJT98765432</span> (10 or T). Spazi ignorati.
      </div>

      <div class="small" style="margin-top:10px"><b>LIN output</b></div>
      <textarea id="linOut" readonly>(will appear here)</textarea>

      <div class="small" style="margin-top:10px"><b>PBN output</b></div>
      <textarea id="pbnOut" readonly>(will appear here)</textarea>

      <div class="row" style="margin-top:10px">
        <button id="copyLin" class="gray">Copy LIN</button>
        <button id="dlLin" class="dark">Download .lin</button>
        <button id="openBSOL" class="dark">Open Bridge Solver Online</button>
        <button id="openBBO" class="dark">Open BBO Handviewer</button>
      </div>
    </div>
  </div>
</div>

<script>
const $ = (id)=>document.getElementById(id);

const pasteBtn = $("pasteBtn");
const fileInput = $("fileInput");
const seatSel = $("seatSel");
const imgPreview = $("imgPreview");
const imgState = $("imgState");
const clickMsg = $("clickMsg");
const debugBox = $("debug");
const ocrBtn = $("ocrBtn");
const genBtn = $("genBtn");
const clearBtn = $("clearBtn");
const valState = $("valState");
const filled = $("filled");
const linOut = $("linOut");
const pbnOut = $("pbnOut");

const copyLinBtn = $("copyLin");
const dlLinBtn = $("dlLin");
const openBSOLBtn = $("openBSOL");
const openBBOBtn = $("openBBO");

const table = {
  N:{S:$("N_S"),H:$("N_H"),D:$("N_D"),C:$("N_C")},
  E:{S:$("E_S"),H:$("E_H"),D:$("E_D"),C:$("E_C")},
  S:{S:$("S_S"),H:$("S_H"),D:$("S_D"),C:$("S_C")},
  W:{S:$("W_S"),H:$("W_H"),D:$("W_D"),C:$("W_C")},
};

let img = null;
let imgW = 0, imgH = 0;
let canvas = document.createElement("canvas");
let ctx = canvas.getContext("2d", { willReadFrequently:true });

let anchor = null; // {x,y} click on ‚ô† icon
let filledSeats = {N:false,E:false,S:false,W:false};

function setDebug(txt){ debugBox.value = txt || ""; }
function appendDebug(txt){ debugBox.value += (debugBox.value? "\n":"") + txt; debugBox.scrollTop = debugBox.scrollHeight; }

function setImageLoaded(ok){
  imgState.textContent = ok ? "loaded ‚úì" : "not loaded";
  imgState.className = ok ? "ok" : "bad";
  imgPreview.style.display = ok ? "block" : "none";
  ocrBtn.disabled = !ok;
}

function refreshFilledUI(){
  const m = (s)=> filledSeats[s] ? "‚úì" : "‚òê";
  filled.textContent = `N ${m("N")} E ${m("E")} S ${m("S")} W ${m("W")}`;
}

function setValidationBadge(ok){
  valState.textContent = ok ? "OK ‚úî" : "KO ‚úñ";
  valState.className = ok ? "ok" : "bad";
}

function normRanks(s){
  if(!s) return "";
  let t = String(s).toUpperCase().replace(/\s+/g,"");
  t = t.replace(/10/g,"T");
  t = t.replace(/[^AKQJT98765432]/g,"");
  return t;
}

function drawToCanvas(){
  if(!img) return;
  canvas.width = imgW; canvas.height = imgH;
  ctx.clearRect(0,0,imgW,imgH);
  ctx.drawImage(img,0,0);
}

async function loadFromBlob(blob){
  const url = URL.createObjectURL(blob);
  return new Promise((resolve,reject)=>{
    const im = new Image();
    im.onload = ()=>{
      img = im;
      imgW = im.naturalWidth || im.width;
      imgH = im.naturalHeight || im.height;
      imgPreview.src = url;
      setImageLoaded(true);
      drawToCanvas();
      setDebug("");
      appendDebug(`Loaded image: ${imgW}x${imgH}`);
      clickMsg.textContent = "Clicca sulla ‚ô† della mano selezionata.";
      anchor = null;
      resolve();
      URL.revokeObjectURL(url);
    };
    im.onerror = reject;
    im.src = url;
  });
}

pasteBtn.addEventListener("click", async ()=>{
  try{
    if(!navigator.clipboard || !navigator.clipboard.read){
      alert("Paste non supportato: usa Upload.");
      return;
    }
    const items = await navigator.clipboard.read();
    for(const it of items){
      const t = it.types.find(x=>x.startsWith("image/"));
      if(t){
        const blob = await it.getType(t);
        await loadFromBlob(blob);
        return;
      }
    }
    alert("Nessuna immagine negli appunti.");
  }catch(e){
    alert("Paste fallito. Usa Upload.\n\n" + e);
  }
});

fileInput.addEventListener("change", async ()=>{
  const f = fileInput.files && fileInput.files[0];
  if(!f) return;
  await loadFromBlob(f);
});

imgPreview.addEventListener("click", (ev)=>{
  if(!img) return;
  const r = imgPreview.getBoundingClientRect();
  const nx = (ev.clientX - r.left) / r.width;
  const ny = (ev.clientY - r.top) / r.height;

  const x = Math.max(0, Math.min(imgW-1, Math.round(nx * imgW)));
  const y = Math.max(0, Math.min(imgH-1, Math.round(ny * imgH)));

  anchor = {x,y};
  clickMsg.textContent = `Anchor set (‚ô† click) at x=${x}, y=${y} | norm(${nx.toFixed(3)}, ${ny.toFixed(3)}) | seat=${seatSel.value}`;
  appendDebug(`Anchor: x=${x} y=${y} seat=${seatSel.value}`);
});

const WHITELIST = "AKQJT9876543210";

function cropLine(x, y, w, h){
  let xx = Math.max(0, Math.min(imgW-2, Math.round(x)));
  let yy = Math.max(0, Math.min(imgH-2, Math.round(y)));
  let ww = Math.max(1, Math.min(imgW-xx, Math.round(w)));
  let hh = Math.max(1, Math.min(imgH-yy, Math.round(h)));

  const c = document.createElement("canvas");
  c.width = ww; c.height = hh;
  const cctx = c.getContext("2d", { willReadFrequently:true });
  cctx.drawImage(canvas, xx, yy, ww, hh, 0,0, ww,hh);

  // threshold
  const id = cctx.getImageData(0,0,ww,hh);
  const d = id.data;
  for(let i=0;i<d.length;i+=4){
    const lum = 0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2];
    const v = lum < 175 ? 0 : 255;
    d[i]=d[i+1]=d[i+2]=v; d[i+3]=255;
  }
  cctx.putImageData(id,0,0);
  return c;
}

async function ocrLine(lineCanvas){
  const res = await Tesseract.recognize(lineCanvas, "eng", {
    tessedit_char_whitelist: WHITELIST,
    preserve_interword_spaces: "0",
  });
  const raw = (res.data && res.data.text) ? res.data.text : "";
  return normRanks(raw);
}

async function ocrHandFromSpadeClick(){
  if(!anchor) throw new Error("Prima clicca sulla ‚ô† della mano selezionata.");
  const seat = seatSel.value;

  const {x,y} = anchor;

  // geometry guesses
  const iconW = Math.max(18, Math.round(imgW * 0.03));
  const xText = x + Math.round(iconW * 1.15);
  const wText = Math.round(imgW * 0.28);
  const lineH = Math.max(26, Math.round(imgH * 0.045));

  // dy candidates (distance between ‚ô† and ‚ô• etc.)
  const dyCandidates = [0.028,0.032,0.036,0.040,0.044,0.048].map(k=>Math.round(imgH*k));

  appendDebug(`OCR seat=${seat} xText=${xText} wText=${wText} lineH=${lineH}`);

  let best = null;
  for(const dy of dyCandidates){
    const out = {S:"",H:"",D:"",C:""};
    const yTopS = y - (lineH*0.60);
    const suits = ["S","H","D","C"];
    let score = 0;

    for(let i=0;i<4;i++){
      const yLineTop = yTopS + i*dy;
      const c = cropLine(xText, yLineTop, wText, lineH);
      const txt = await ocrLine(c);
      out[suits[i]] = txt;
      score += txt.length;
    }

    const total = out.S.length + out.H.length + out.D.length + out.C.length;
    const perOk = [out.S,out.H,out.D,out.C].every(v=>v.length<=13);
    const closeness = 20 - Math.min(20, Math.abs(13 - total));
    const bonus = perOk ? 8 : 0;
    const totalScore = score + closeness + bonus;

    appendDebug(`dy=${dy} => S=${out.S} H=${out.H} D=${out.D} C=${out.C} total=${total} score=${totalScore}`);

    if(!best || totalScore > best.totalScore){
      best = {dy, out, total, totalScore};
    }
  }

  appendDebug(`BEST dy=${best.dy} total=${best.total} S=${best.out.S} H=${best.out.H} D=${best.out.D} C=${best.out.C}`);

  table[seat].S.value = best.out.S || "";
  table[seat].H.value = best.out.H || "";
  table[seat].D.value = best.out.D || "";
  table[seat].C.value = best.out.C || "";

  filledSeats[seat] = (best.total === 13);
  refreshFilledUI();
}

function readHands(){
  const hands = {};
  for(const seat of ["N","E","S","W"]){
    hands[seat] = {
      S: normRanks(table[seat].S.value),
      H: normRanks(table[seat].H.value),
      D: normRanks(table[seat].D.value),
      C: normRanks(table[seat].C.value),
    };
    table[seat].S.value = hands[seat].S;
    table[seat].H.value = hands[seat].H;
    table[seat].D.value = hands[seat].D;
    table[seat].C.value = hands[seat].C;
  }
  return hands;
}

function validateHands(h){
  const counts = {N:0,E:0,S:0,W:0,total:0};
  const seen = new Map();
  const errs = [];

  for(const seat of ["N","E","S","W"]){
    counts[seat] = h[seat].S.length + h[seat].H.length + h[seat].D.length + h[seat].C.length;
    counts.total += counts[seat];
    if(counts[seat] !== 13) errs.push(`Seat ${seat}: ${counts[seat]} carte (attese 13)`);
  }
  if(counts.total !== 52) errs.push(`Totale carte: ${counts.total} (attese 52)`);

  for(const seat of ["N","E","S","W"]){
    for(const suit of ["S","H","D","C"]){
      for(const r of h[seat][suit]){
        const k = suit+r;
        seen.set(k, (seen.get(k)||0)+1);
      }
    }
  }
  const dups = [...seen.entries()].filter(([k,v])=>v>1).map(([k,v])=>`${k}√ó${v}`);
  if(dups.length) errs.push(`Duplicati: ${dups.slice(0,30).join(", ")}${dups.length>30?" ...":""}`);

  return {ok: errs.length===0, errs, counts};
}

function makePBN(h){
  const N = `${h.N.S}.${h.N.H}.${h.N.D}.${h.N.C}`;
  const E = `${h.E.S}.${h.E.H}.${h.E.D}.${h.E.C}`;
  const S = `${h.S.S}.${h.S.H}.${h.S.D}.${h.S.C}`;
  const W = `${h.W.S}.${h.W.H}.${h.W.D}.${h.W.C}`;
  return [
    `[Event "MK EasyHand"]`,
    `[Dealer "N"]`,
    `[Vulnerable "None"]`,
    `[Deal "N:${N} ${E} ${S} ${W}"]`,
    ``
  ].join("\n");
}

function makeLIN(h){
  const bd = 1;
  const N = `${h.N.S}${h.N.H}${h.N.D}${h.N.C}`;
  const E = `${h.E.S}${h.E.H}${h.E.D}${h.E.C}`;
  const S = `${h.S.S}${h.S.H}${h.S.D}${h.S.C}`;
  const W = `${h.W.S}${h.W.H}${h.W.D}${h.W.C}`;
  return `pn|N,E,S,W|sv|o|bd|${bd}|md|3${N},${W},${E},${S}|`;
}

function updateOutputs(){
  const h = readHands();
  const v = validateHands(h);

  if(v.ok){
    setValidationBadge(true);
  }else{
    setValidationBadge(false);
    appendDebug("Validation KO:\n- " + v.errs.join("\n- "));
  }

  const lin = makeLIN(h);
  const pbn = makePBN(h);
  linOut.value = lin;
  pbnOut.value = pbn;

  // Bridge Solver Online (ddummy)
  const baseSolver = "https://dds.bridgewebs.com/bsol2/ddummy.htm";
  const params = new URLSearchParams({
    board: "1",
    dealer: "N",
    vul: "None",
    north: `${h.N.S}.${h.N.H}.${h.N.D}.${h.N.C}`,
    east:  `${h.E.S}.${h.E.H}.${h.E.D}.${h.E.C}`,
    south: `${h.S.S}.${h.S.H}.${h.S.D}.${h.S.C}`,
    west:  `${h.W.S}.${h.W.H}.${h.W.D}.${h.W.C}`,
    analyse: "true"
  });
  openBSOLBtn.onclick = ()=> window.open(baseSolver + "?" + params.toString(), "_blank", "noopener");

  // BBO handviewer with LIN
  const bboBase = "https://www.bridgebase.com/tools/handviewer.html";
  openBBOBtn.onclick = ()=> window.open(bboBase + "?lin=" + encodeURIComponent(lin), "_blank", "noopener");
}

ocrBtn.addEventListener("click", async ()=>{
  if(!img){ alert("Paste o Upload prima."); return; }
  if(!anchor){ alert("Clicca sulla ‚ô† della mano selezionata."); return; }
  ocrBtn.disabled = true;
  try{
    await ocrHandFromSpadeClick();
  }catch(e){
    appendDebug("OCR ERROR: " + (e?.message||String(e)));
    alert("OCR error: " + e);
  }finally{
    ocrBtn.disabled = false;
  }
});

genBtn.addEventListener("click", updateOutputs);

clearBtn.addEventListener("click", ()=>{
  for(const seat of ["N","E","S","W"]){
    for(const su of ["S","H","D","C"]){
      table[seat][su].value = "";
    }
  }
  filledSeats = {N:false,E:false,S:false,W:false};
  refreshFilledUI();
  setValidationBadge(false);
  setDebug("");
  linOut.value="(will appear here)";
  pbnOut.value="(will appear here)";
  clickMsg.textContent = "No click yet.";
  anchor = null;
});

copyLinBtn.addEventListener("click", async ()=>{
  const t = linOut.value.trim();
  if(!t || t.includes("will appear")) return;
  try{
    await navigator.clipboard.writeText(t);
    appendDebug("LIN copiato ‚úÖ");
  }catch(e){
    alert("Copy failed.");
  }
});

dlLinBtn.addEventListener("click", ()=>{
  const t = linOut.value.trim();
  if(!t || t.includes("will appear")) return;
  const blob = new Blob([t], {type:"text/plain"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "hand.lin";
  document.body.appendChild(a);
  a.click();
  a.remove();
});

for(const seat of ["N","E","S","W"]){
  for(const su of ["S","H","D","C"]){
    table[seat][su].addEventListener("input", ()=>{
      const tmp = {
        S: normRanks(table[seat].S.value),
        H: normRanks(table[seat].H.value),
        D: normRanks(table[seat].D.value),
        C: normRanks(table[seat].C.value),
      };
      const cnt = tmp.S.length + tmp.H.length + tmp.D.length + tmp.C.length;
      filledSeats[seat] = (cnt===13);
      refreshFilledUI();
    });
  }
}

setImageLoaded(false);
refreshFilledUI();
setValidationBadge(false);
linOut.value="(will appear here)";
pbnOut.value="(will appear here)";
setDebug("");
</script>
</body>
</html>
