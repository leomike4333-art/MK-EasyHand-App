<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>MK EasyHand App</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:#f6f6f6;color:#111}
    header{background:#eee;padding:14px 16px;border-bottom:1px solid #ddd}
    h1{margin:0;font-size:22px}
    .sub{margin:4px 0 0 0;color:#444;font-size:13px}
    .wrap{max-width:980px;margin:14px auto;padding:0 12px}
    .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
    .card{background:#fff;border:1px solid #ddd;border-radius:10px;padding:12px}
    .card h2{margin:0 0 8px 0;font-size:16px}
    select, input[type="number"], input[type="text"]{padding:8px;border:1px solid #bbb;border-radius:8px}
    button{padding:10px 12px;border:0;border-radius:10px;color:#fff;cursor:pointer}
    .btn{background:#2563eb}
    .btn2{background:#111827}
    .btn3{background:#16a34a}
    .btn4{background:#b91c1c}
    button:disabled{opacity:.5;cursor:not-allowed}
    .small{font-size:12px;color:#444}
    #imgPreview{max-width:100%;border:1px solid #ccc;border-radius:10px;margin-top:8px;display:none}
    #clickMsg{margin-top:6px}
    #cropPreview{max-width:100%;border:1px dashed #999;border-radius:10px;margin-top:8px;display:none}
    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media (max-width:800px){.grid2{grid-template-columns:1fr}}
    .handGrid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .handBox{background:#fff;border:1px solid #ddd;border-radius:10px;padding:10px}
    .handTitle{font-weight:700;margin-bottom:6px}
    .suitRow{display:grid;grid-template-columns:26px 1fr;gap:8px;align-items:center;margin:6px 0}
    .suit{font-size:18px}
    .out{width:100%;height:100px;border:1px solid #bbb;border-radius:10px;padding:8px;font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
    .pill{display:inline-block;padding:4px 8px;border-radius:999px;font-size:12px}
    .ok{background:#dcfce7;color:#166534;border:1px solid #86efac}
    .ko{background:#fee2e2;color:#991b1b;border:1px solid #fecaca}
    .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;font-size:12px;white-space:pre-wrap}
  </style>
</head>
<body>
<header>
  <h1>MK EasyHand App</h1>
  <div class="sub">Screenshot ‚Üí Paste ‚Üí Click suit icon ‚Üí OCR ‚Üí Generate LIN/PBN ‚Üí Open Solver / BBO</div>
</header>

<div class="wrap">

  <div class="card">
    <div class="row">
      <label class="small"><b>Source:</b></label>
      <select id="sourceSel">
        <option value="A">A ‚Äî RealBridge</option>
        <option value="B">B ‚Äî BBO</option>
        <option value="C" selected>C ‚Äî Federation / Local (FIGB)</option>
        <option value="D">D ‚Äî LoveBridge (WBF)</option>
        <option value="E">E ‚Äî Bulletin (ACBL/EBL/WBF)</option>
      </select>

      <button id="pasteBtn" class="btn">üìã Paste</button>
      <input type="file" id="fileInput" accept="image/*" />

      <span id="imgMsg" class="small"></span>

      <button id="ocrBtn" class="btn3" disabled>üîé OCR from click (S/H/D/C)</button>
      <button id="clearBtn" class="btn4">Clear</button>
    </div>

    <div class="small" style="margin-top:8px">
      <b>How it works:</b> paste/upload ‚Üí click near a suit icon (‚ô†/‚ô•/‚ô¶/‚ô£) next to the cards ‚Üí press OCR.<br/>
      Best for FIGB / ‚Äúvertical‚Äù screenshots. You can repeat OCR for different seats if you want.
    </div>

    <img id="imgPreview" alt="preview" />
    <div id="clickMsg" class="small"></div>

    <canvas id="cropCanvas" style="display:none"></canvas>
    <img id="cropPreview" alt="crop preview" />
    <div id="ocrText" class="mono" style="margin-top:8px"></div>
  </div>

  <div class="card" style="margin-top:12px">
    <div class="row" style="justify-content:space-between;gap:12px">
      <div>
        <b>Status:</b>
        <span id="valPill" class="pill ko">Validation: KO</span>
        <span id="valMsg" class="small"></span>
      </div>
      <div class="row">
        <button id="genBtn" class="btn3">Generate LIN / PBN (validate)</button>
      </div>
    </div>
  </div>

  <div class="handGrid" style="margin-top:12px">

    <div class="handBox">
      <div class="handTitle">North</div>
      <div class="suitRow"><div class="suit">‚ô†</div><input id="nS" type="text" placeholder="e.g. AKQJ" /></div>
      <div class="suitRow"><div class="suit">‚ô•</div><input id="nH" type="text" placeholder="e.g. T987" /></div>
      <div class="suitRow"><div class="suit">‚ô¶</div><input id="nD" type="text" placeholder="e.g. 642" /></div>
      <div class="suitRow"><div class="suit">‚ô£</div><input id="nC" type="text" placeholder="e.g. A73" /></div>
    </div>

    <div class="handBox">
      <div class="handTitle">East</div>
      <div class="suitRow"><div class="suit">‚ô†</div><input id="eS" type="text" /></div>
      <div class="suitRow"><div class="suit">‚ô•</div><input id="eH" type="text" /></div>
      <div class="suitRow"><div class="suit">‚ô¶</div><input id="eD" type="text" /></div>
      <div class="suitRow"><div class="suit">‚ô£</div><input id="eC" type="text" /></div>
    </div>

    <div class="handBox">
      <div class="handTitle">South</div>
      <div class="suitRow"><div class="suit">‚ô†</div><input id="sS" type="text" /></div>
      <div class="suitRow"><div class="suit">‚ô•</div><input id="sH" type="text" /></div>
      <div class="suitRow"><div class="suit">‚ô¶</div><input id="sD" type="text" /></div>
      <div class="suitRow"><div class="suit">‚ô£</div><input id="sC" type="text" /></div>
    </div>

    <div class="handBox">
      <div class="handTitle">West</div>
      <div class="suitRow"><div class="suit">‚ô†</div><input id="wS" type="text" /></div>
      <div class="suitRow"><div class="suit">‚ô•</div><input id="wH" type="text" /></div>
      <div class="suitRow"><div class="suit">‚ô¶</div><input id="wD" type="text" /></div>
      <div class="suitRow"><div class="suit">‚ô£</div><input id="wC" type="text" /></div>
    </div>

  </div>

  <div class="grid2" style="margin-top:12px">
    <div class="card">
      <h2>LIN output</h2>
      <textarea id="linOut" class="out" readonly></textarea>
      <div class="row">
        <button id="copyLin" class="btn2">Copy LIN</button>
        <button id="dlLin" class="btn">Download .lin</button>
        <button id="openSolver" class="btn2">Open Bridge Solver Online</button>
        <button id="openBBO" class="btn2">Open BBO Handviewer</button>
      </div>
      <div class="small" style="margin-top:6px">
        Tip: if you don‚Äôt see changes on GitHub Pages, hard-refresh (Ctrl+F5) or change URL like <span class="mono">?v=123</span>.
      </div>
    </div>

    <div class="card">
      <h2>PBN output</h2>
      <textarea id="pbnOut" class="out" readonly></textarea>
      <div class="small">
        PBN is useful for many solvers / tools. LIN is best for BBO / quick sharing.
      </div>
      <h2 style="margin-top:10px">Debug</h2>
      <div id="dbg" class="mono"></div>
    </div>
  </div>

</div>

<!-- Tesseract.js (OCR in browser) -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

<script>
/* -------------------------
  Helpers
------------------------- */
const $ = (id)=>document.getElementById(id);

const imgPreview = $("imgPreview");
const cropCanvas = $("cropCanvas");
const cropPreview = $("cropPreview");
const imgMsg = $("imgMsg");
const clickMsg = $("clickMsg");
const ocrBtn = $("ocrBtn");
const ocrText = $("ocrText");
const sourceSel = $("sourceSel");
const dbg = $("dbg");

let lastClick = null;        // {x,y} in image pixel coords
let loadedImage = null;      // HTMLImageElement
let imgScale = 1;            // display scale (for click mapping)

/* normalize ranks: accept 10 or T; remove spaces; uppercase */
function normRanks(s){
  if(!s) return "";
  s = (""+s).toUpperCase().replace(/\s+/g,"");
  s = s.replace(/10/g,"T");
  // keep only AKQJT98765432
  s = s.replace(/[^AKQJT98765432]/g,"");
  return s;
}

/* write to inputs */
function setHand(seat, sp, he, di, cl){
  $(seat+"S").value = normRanks(sp);
  $(seat+"H").value = normRanks(he);
  $(seat+"D").value = normRanks(di);
  $(seat+"C").value = normRanks(cl);
}

/* count cards */
function countCards(s){ return (s||"").length; }

/* validate 52 cards, no duplicates */
function validateAll(){
  const seats = ["n","e","s","w"];
  const suits = ["S","H","D","C"];
  let all = [];
  let perSeat = {};
  let errors = [];

  for(const seat of seats){
    perSeat[seat]=0;
    for(const su of suits){
      const v = normRanks($(seat+su).value);
      $(seat+su).value = v;
      perSeat[seat] += v.length;
      for(const ch of v){
        all.push(seat+su+ch); // id with suit+rank
      }
    }
    if(perSeat[seat]!==13){
      errors.push(`Seat ${seat.toUpperCase()}: ${perSeat[seat]} cards (expected 13)`);
    }
  }

  // duplicates by suit+rank across seats
  // build true identity suit+rank (ignore seat)
  const id = [];
  for(const seat of seats){
    for(const su of suits){
      const v = normRanks($(seat+su).value);
      for(const ch of v){
        id.push(su+ch);
      }
    }
  }
  const freq = {};
  for(const x of id) freq[x]=(freq[x]||0)+1;
  const dups = Object.entries(freq).filter(([k,v])=>v>1);
  if(dups.length){
    errors.push("Duplicates: " + dups.map(([k,v])=>`${k}√ó${v}`).join(", "));
  }

  const total = id.length;
  if(total!==52) errors.push(`Total cards: ${total} (expected 52)`);

  const ok = errors.length===0;
  $("valPill").className = "pill " + (ok ? "ok":"ko");
  $("valPill").textContent = "Validation: " + (ok ? "OK ‚úÖ":"KO ‚ùå");
  $("valMsg").textContent = ok ? "" : (" ‚Äî " + errors[0]);
  dbg.textContent = `Validation: OK=${ok}  total=${total}\n` + (errors.length?("Errors:\n- "+errors.join("\n- ")):"No errors.");
  return ok;
}

/* build LIN + PBN (minimal) */
function buildLIN(){
  // Format for BBO-like deal: md|<dealer><hands...> is variable; we use a simple "md|1" style with N as dealer for now.
  // We'll keep dealer/vul out for now (as you requested). Users can change in Solver anyway.
  // hands order: N,E,S,W in S,H,D,C with commas
  const n = `S${$("nS").value}H${$("nH").value}D${$("nD").value}C${$("nC").value}`;
  const e = `S${$("eS").value}H${$("eH").value}D${$("eD").value}C${$("eC").value}`;
  const s = `S${$("sS").value}H${$("sH").value}D${$("sD").value}C${$("sC").value}`;
  const w = `S${$("wS").value}H${$("wH").value}D${$("wD").value}C${$("wC").value}`;
  // Simple LIN; many viewers accept: md|1<deal>| where 1=North dealer; we keep it consistent.
  return `pn|N,E,S,W|sv|o|bd|1|md|1${n},${e},${s},${w}|`;
}
function buildPBN(){
  // PBN Deal: "N:... ... ... ..."
  const N = `${$("nS").value}.${$("nH").value}.${$("nD").value}.${$("nC").value}`;
  const E = `${$("eS").value}.${$("eH").value}.${$("eD").value}.${$("eC").value}`;
  const S = `${$("sS").value}.${$("sH").value}.${$("sD").value}.${$("sC").value}`;
  const W = `${$("wS").value}.${$("wH").value}.${$("wD").value}.${$("wC").value}`;
  return `[Deal "N:${N} ${E} ${S} ${W}"]`;
}

/* -------------------------
  Image load: paste / file
------------------------- */
$("pasteBtn").addEventListener("click", async ()=>{
  try{
    const items = await navigator.clipboard.read();
    for(const item of items){
      for(const type of item.types){
        if(type.startsWith("image/")){
          const blob = await item.getType(type);
          const url = URL.createObjectURL(blob);
          await loadImage(url);
          imgMsg.textContent = "Image pasted from clipboard ‚úÖ";
          return;
        }
      }
    }
    imgMsg.textContent = "No image found in clipboard.";
  }catch(e){
    imgMsg.textContent = "Paste blocked by browser. Try Ctrl+V or use file input.";
  }
});

$("fileInput").addEventListener("change", async ()=>{
  const f = $("fileInput").files && $("fileInput").files[0];
  if(!f) return;
  const url = URL.createObjectURL(f);
  await loadImage(url);
  imgMsg.textContent = "Image loaded ‚úÖ";
});

async function loadImage(url){
  return new Promise((resolve,reject)=>{
    const img = new Image();
    img.onload = ()=>{
      loadedImage = img;
      imgPreview.src = url;
      imgPreview.style.display = "block";
      cropPreview.style.display = "none";
      ocrText.textContent = "";
      clickMsg.textContent = "Click near a suit icon (‚ô†/‚ô•/‚ô¶/‚ô£) to set OCR anchor.";
      lastClick = null;
      ocrBtn.disabled = true;
      resolve();
    };
    img.onerror = reject;
    img.src = url;
  });
}

/* click mapping */
imgPreview.addEventListener("click", (ev)=>{
  if(!loadedImage) return;
  const r = imgPreview.getBoundingClientRect();
  const cx = ev.clientX - r.left;
  const cy = ev.clientY - r.top;
  // map to image pixels
  const sx = loadedImage.width / r.width;
  const sy = loadedImage.height / r.height;
  const x = Math.round(cx * sx);
  const y = Math.round(cy * sy);
  lastClick = {x,y};
  ocrBtn.disabled = false;
  clickMsg.textContent = `Clicked at x=${x}, y=${y} (image px). Now press OCR.`;
});

/* -------------------------
  OCR from click (anchor = suit icons)
  Strategy (MVP):
  - crop a rectangle around click that should include 4 lines (S/H/D/C + ranks)
  - run OCR on crop
  - parse the 4 suit lines
------------------------- */

$("ocrBtn").addEventListener("click", async ()=>{
  if(!loadedImage || !lastClick) return;

  const src = sourceSel.value;

  // Heuristic crop sizes by source (tuned for FIGB vertical; still works for others)
  let W = 360, H = 360, xPadLeft = 30, yPadTop = 30;

  if(src==="C"){ // FIGB: symbols left, ranks right (vertical)
    W = 420; H = 420; xPadLeft = 40; yPadTop = 50;
  } else if(src==="B"){ // BBO: more compact
    W = 360; H = 360; xPadLeft = 40; yPadTop = 40;
  } else if(src==="A"){ // RealBridge
    W = 380; H = 380; xPadLeft = 40; yPadTop = 40;
  } else if(src==="D"){ // LoveBridge cards in small boxes
    W = 420; H = 420; xPadLeft = 60; yPadTop = 60;
  } else if(src==="E"){ // Bulletin (often very clean, but can be small)
    W = 480; H = 420; xPadLeft = 60; yPadTop = 50;
  }

  const x0 = Math.max(0, lastClick.x - xPadLeft);
  const y0 = Math.max(0, lastClick.y - yPadTop);
  const x1 = Math.min(loadedImage.width, x0 + W);
  const y1 = Math.min(loadedImage.height, y0 + H);

  // draw crop to canvas
  cropCanvas.width = x1-x0;
  cropCanvas.height = y1-y0;
  const ctx = cropCanvas.getContext("2d");
  ctx.drawImage(loadedImage, x0, y0, x1-x0, y1-y0, 0, 0, x1-x0, y1-y0);

  // show crop preview
  cropPreview.src = cropCanvas.toDataURL("image/png");
  cropPreview.style.display = "block";

  ocrText.textContent = "OCR running‚Ä¶ (first time may be slower)";

  // OCR
  const { data } = await Tesseract.recognize(cropCanvas, "eng", {
    logger: m => { /* console.log(m) */ }
  });

  const raw = (data && data.text) ? data.text : "";
  ocrText.textContent = "OCR text:\n" + raw;

  // Parse: try to find four lines corresponding to suits.
  // We accept either actual suit symbols or letters S/H/D/C.
  // We'll build a best-effort extraction from the OCR output.
  const parsed = parseSuitBlock(raw);

  // Decide where to place (which seat): we keep it simple:
  // user picks the seat by clicking near its suit icons; we ask them via a prompt? (avoid).
  // MVP: we fill first empty seat among N/E/S/W.
  const seat = firstEmptySeat();
  if(!seat){
    // if none empty, overwrite South (common) to make behavior deterministic
    fillSeat("s", parsed);
  } else {
    fillSeat(seat, parsed);
  }

  validateAll();
});

/* find first seat with all suits empty */
function firstEmptySeat(){
  const seats = ["n","e","s","w"];
  for(const seat of seats){
    const allEmpty = ["S","H","D","C"].every(su => !$(seat+su).value);
    if(allEmpty) return seat;
  }
  return null;
}

function fillSeat(seat, parsed){
  // parsed = {S,H,D,C}
  $(seat+"S").value = normRanks(parsed.S||"");
  $(seat+"H").value = normRanks(parsed.H||"");
  $(seat+"D").value = normRanks(parsed.D||"");
  $(seat+"C").value = normRanks(parsed.C||"");
}

/* Parse OCR text into {S,H,D,C}.
   Strategy:
   - split lines, normalize
   - detect lines containing suit markers or starting with suit letter
   - extract ranks substring after the marker
*/
function parseSuitBlock(text){
  const lines = (text||"")
    .split(/\r?\n/)
    .map(x=>x.trim())
    .filter(x=>x.length);

  // Normalize symbols to letters to help parsing
  const normLine = (s)=>s
    .replace(/‚ô†/g,"S")
    .replace(/‚ô•/g,"H")
    .replace(/‚ô¶/g,"D")
    .replace(/‚ô£/g,"C")
    .replace(/[^A-Za-z0-9]/g," "); // keep alnum separated

  const out = {S:"",H:"",D:"",C:""};

  // pass 1: look for explicit suit prefix at line start
  for(const L0 of lines){
    const L = normLine(L0).trim().toUpperCase();
    // patterns like "S AJ542" or "H K6543"
    const m = L.match(/^([SHDC])\s+(.+)$/);
    if(m){
      out[m[1]] = normRanks(m[2]);
    }
  }

  // pass 2: if missing, try to find any line containing a suit letter then ranks
  if(!out.S || !out.H || !out.D || !out.C){
    for(const L0 of lines){
      const L = normLine(L0).trim().toUpperCase();
      // find segments like "S AJ542" inside the line
      const rx = /([SHDC])\s+([AKQJT0-9]+)/g;
      let mm;
      while((mm = rx.exec(L)) !== null){
        const su = mm[1];
        const ranks = mm[2];
        if(!out[su]) out[su] = normRanks(ranks);
      }
    }
  }

  // If OCR collapsed into one line without suit markers,
  // we fallback to "best guess": pick the 4 longest rank strings in order S,H,D,C.
  if(!(out.S && out.H && out.D && out.C)){
    const candidates = [];
    for(const L0 of lines){
      const s = normRanks(L0);
      if(s.length>=1) candidates.push(s);
    }
    candidates.sort((a,b)=>b.length-a.length);
    // naive assign if still empty
    const order = ["S","H","D","C"];
    let idx=0;
    for(const su of order){
      if(!out[su] && candidates[idx]) out[su]=candidates[idx++];
    }
  }

  return out;
}

/* -------------------------
  Generate outputs
------------------------- */
$("genBtn").addEventListener("click", ()=>{
  const ok = validateAll();
  if(!ok){
    $("linOut").value = "";
    $("pbnOut").value = "";
    return;
  }
  const lin = buildLIN();
  const pbn = buildPBN();
  $("linOut").value = lin;
  $("pbnOut").value = pbn;
});

/* Copy / Download */
$("copyLin").addEventListener("click", async ()=>{
  const t = $("linOut").value;
  if(!t) return;
  await navigator.clipboard.writeText(t);
  $("valMsg").textContent = "LIN copied ‚úÖ";
});

$("dlLin").addEventListener("click", ()=>{
  const t = $("linOut").value;
  if(!t) return;
  const blob = new Blob([t], {type:"text/plain"});
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = "hand.lin";
  a.click();
});

/* Open external tools (simple URLs) */
$("openSolver").addEventListener("click", ()=>{
  // Bridge Solver Online: easiest is to open homepage; users can paste LIN or use their workflow
  window.open("https://www.bridgebase.com/tools/handviewer.html", "_blank");
});
$("openBBO").addEventListener("click", ()=>{
  // BBO Handviewer accepts LIN; simplest: open handviewer and paste LIN
  window.open("https://www.bridgebase.com/tools/handviewer.html", "_blank");
});

/* Clear */
$("clearBtn").addEventListener("click", ()=>{
  ["n","e","s","w"].forEach(seat=>{
    ["S","H","D","C"].forEach(su=>$(seat+su).value="");
  });
  $("linOut").value="";
  $("pbnOut").value="";
  $("valPill").className="pill ko";
  $("valPill").textContent="Validation: KO";
  $("valMsg").textContent="";
  dbg.textContent="";
  ocrText.textContent="";
  cropPreview.style.display="none";
});

/* validate as user types */
["n","e","s","w"].forEach(seat=>{
  ["S","H","D","C"].forEach(su=>{
    $(seat+su).addEventListener("input", ()=>validateAll());
  });
});
</script>
</body>
</html>
